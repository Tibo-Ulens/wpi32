(*
	THIS IS ONLY A LOOSE REFERENCE

	IT WILL CONTAIN MISTAKES AND WILL NOT MATCH THE IMPLEMENTATION GRAMMAR
	ONE FOR ONE
*)

(* Lexical grammar *)

newline = ?r"\n"?;
whitespace = ?r"\s"?;

comma = { " " | "\t" }, ",", { " " | "\t" };

comment = ";", { ?r"[^\n]*"? };

string = '"', { ?r'[^"]'? | '\"' }, '"';
char = "'", ( ?r"[^']"? | "\'" ), "'";
number = decimal_number
	| hex_number
	| octal_number
	| binary_number;

decimal_number = ?r"[0-9]+"?;
hex_number = "0x", ?r"[a-fA-F0-9]+"?;
octal_number = "0o", ?r"[0-7]+"?;
binary_number = "0b", ?r"[0-1]+"?;

identifier_initial = ?r"[a-zA-Z!$&?^_~@?]"?;
identifier_subsequent = identifier_initial | ?r"0-9"?;

label = identifier_initial, { identifier_subsequent };
label_define = label, ":";
local_label = ".", label;
local_label_define = local_label, ":";

(* Syntactical grammar *)

root = { section };
section = text_section | data_section | bss_section;

text_section = text_header, { text_line };
text_header = "$SECTION", "TEXT", newline;

data_section = data_header, { data_line };
data_header = "$SECTION", "DATA", newline;

bss_section = bss_header, { bss_line };
bss_header = "$SECTION", "BSS", newline;

label_id = label_define | local_label_define;

(* text section *)

text_line = { whitespace },
	[ annotated_text_line | raw_text_line ]
	[ comment ],
	newline;

annotated_text_line = label_id,
	[ equ_directive | text_repeat_directive | instruction ];
raw_text_line = [ text_repeat_directive | instruction ];

text_repeat_directive = "$REPEAT", immediate, instruction;

(* /text section *)
(* data section *)

data_line = { whitespace },
	[ label_id ],
	[ annotated_data_line | raw_data_line ],
	[ comment ]
	newline;

annotated_data_line = label_id, [ equ_directive, data_directive ];
raw_data_line = [ data_directive ];

data_directive = bytes_directive
	| halves_directive
	| words_directive
	| data_repeat_directive;

bytes_directive = "$BYTES", literal, { comma, literal };
halves_directive = "$HALVES", literal, { comma, literal };
words_directive = "$WORDS", literal, { comma, literal };
data_repeat_directive = "$REPEAT", immediate, data_directive;

(* /data section *)
(* bss section *)

bss_line = { whitespace },
	[ label_id ],
	[ annotated_bss_line | raw_bss_line ],
	[ comment ]
	newline;

annotated_bss_line = label_id, [ equ_directive, bss_directive ];
raw_bss_line = [ bss_directive ];

bss_directive = res_bytes_directive
	| res_halves_directive
	| res_words_directive
	| bss_repeat_directive;

res_bytes_directive = "$RES_BYTES", number, { comma, number };
res_halves_directive = "$RES_HALVES", number, { comma, number };
res_words_directive = "$RES_WORDS", number, { comma, number };
bss_repeat_directive = "$REPEAT", immediate, bss_directive;

(* /bss section *)

equ_directive = "$EQU", literal;

literal = string | char | immediate;

immediate = logicor_imm, { "?", logicor_imm, ":", logicor_imm };
logicor_imm = logicxor_imm, { "||", logicxor_imm };
logicxor_imm = logicand_imm, { "^^", logicand_imm };
logicand_imm = or_imm, { "&&", or_imm };
or_imm = xor_imm, { "|", xor_imm };
xor_imm = and_imm, { "^", and_imm};
and_imm = eq_imm, { "&", eq_imm};
eq_imm = ord_imm, { ( "==", ord_imm ) | ( "!=", ord_imm ) };
ord_imm = ord_imm, {
	("<", shift_imm )
	| ( "<=", shift_imm)
	| ( ">", shift_imm )
	| ( ">=", shift_imm )
};
shift_imm = addsub_imm, {
	( "<<", addsub_imm )
	| ( ">>", addsub_imm )
	| ( ">>>", addsub_imm )
};
addsub_imm = muldivrem_imm, {
	( "+", muldivrem_imm )
	| ( "-", muldivrem_imm )
};
muldivrem_imm = operand, {
	( "*", operand )
	| ( "/", operand )
	| ( "%", operand )
};
operand = label | local_label | number | ( "(", immediate, ")" );

address_calculation = "[", register, "+" | "-", immediate, "]";

instruction = integer_register_immediate_instruction
	| integer_register_register_instruction
	| upper_immediate_instruction
	| jump_instruction
	| jump_register_instruction
	| branch_instruction
	| load_instruction
	| store_instruction
	| memory_ordering_instruction
	| environment_instruction
	| fence_instruction
	| csr_register_instruction
	| csr_immediate_instruction
	| multiply_instruction
	| divide_instruction
	| remainder_instruction;

register = "r0" | "r1" | "r2" | "r3" | "r4" | "r5" | "r6" | "r7" | "r8" | "r9"
	| "r10" | "r11" | "r12" | "r13" | "r14" | "r15" | "r16" | "r17" | "r18"
	| "r19" | "r20" | "r21" | "r22" | "r23" | "r24" | "r25" | "r26" | "r27"
	| "r28" | "r29" | "r30" | "r31"
	| "zero" | "ra" | "sp" | "gp" | "tp" | "fp"
	| "t0" | "t1" | "t2" | "t3" | "t4" | "t5" | "t6"
	| "s0" | "s1" | "s2" | "s3" | "s4" | "s5" | "s6" | "s7" | "s8" | "s9"
	| "s10" | "s11"
	| "a0" | "a1" | "a2" | "a3" | "a4" | "a5" | "a6" | "a7";

integer_register_immediate_instruction =
	( "addi" | "slti" | "sltiu" | "andi" | "ori" | "xori" | "lsli" | "lsri" | "asri" ), whitespace,
	register, comma,
	register, comma,
	immediate
;

integer_register_register_instruction =
	( "add" | "slt" | "sltu" | "and" | "or" | "xor" | "lsl" | "lsr" | "asr" | "sub" ), whitespace,
	register, comma,
	register, comma,
	register
;

upper_immediate_instruction =
	( "lui" | "auipc" ), whitespace,
	register, comma,
	immediate
;

jump_instruction = "jal", comma, register, comma, immediate;
jump_register_instruction =
	"jalr", whitespace,
	register, comma,
	register, comma,
	immediate;

branch_instruction =
	( "beq" | "bne" | "blt" | "bltu" | "bge" | "bgeu" ), whitespace,
	register, comma,
	register, comma,
	immediate
;

load_instruction =
	( "lb" | "lbu" | "lh" | "lhu" | "lw" ), whitespace,
	register, comma,
	address_calculation
;
store_instruction =
	( "sb", "sh", "sw" ), whitespace,
	register, comma,
	address_calculation
;

memory_ordering_instruction =
	( "fence", whitespace, ordering_operation, comma, ordering_operation )
	| total_store_ordering_instruction;
ordering_operation = [ "i" ], [ "o" ], [ "r" ], [ "w" ];
total_store_ordering_instruction = "fence.tso";

environment_instruction = ( "ecall" | "ebreak" );

fence_instruction = "fence.i";

csr_register_instruction =
	( "csrrw"  | "csrrs" | "csrrc" ), whitespace,
	register, comma,
	register, comma,
	register
;
csr_immediate_instruction =
	( "csrrwi"  | "csrrsi" | "csrrci" ), whitespace,
	register, comma,
	immediate, comma,
	register
;

multiply_instruction =
	( "mul" | "mulh" | "mulhu" | "mulhsu" ), whitespace,
	register, comma,
	register, comma,
	register
;
divide_instruction =
	( "div" | "divu" ), whitespace,
	register, comma,
	register, comma,
	register
;
remainder_instruction =
	( "rem" | "remu" ), whitespace,
	register, comma,
	register, comma,
	register
;
